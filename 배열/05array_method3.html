<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //01. 원본배열을 변경하는 메소드
        //🖤push() / pop() / shift() / unshift()🖤
        //🖤splice()🖤 / reverse()
        let dogs = ['콩이','흰둥이','크림','구름','검둥이'];   //이 배열의 마지막 인덱스=length-1임  인덱스번호[0,1,2,3,4]
        dogs[dogs.length] = '사랑이';       //배열의 길이는 5 ->[5]이걸 인덱스로 주면 인덱스가 추가로 생김
        dogs.push('나추가');                   //맨마지막 추가
        dogs.unshift('앞에추가');              //맨앞 추가
        dogs.shift();                         //맨앞 삭제
        dogs.pop();                           //맨마지막 삭제
        dogs.pop();
        console.log(dogs);
        dogs.reverse();                       //순서를 반대로
        console.log(dogs);
        //splice() 내가 원하는 위치의 값부터 제거 가능, 추가도 가능
        //splice(start, num갯수, '추가하는값')
        //흰둥이와 크림 지우고 누렁이 넣기
        // dogs.splice(1,2,'누렁이');
                 //1번 인덱스인 흰둥이 부터~ 2개를 지운다 + 누렁이 값을 넣어준다
        //제거 안하고 그 위치에 추가하고 싶을 때 ->num 갯수 자리에 0 해주기
        // dogs.splice(1,0,'누렁이');
        //제거만 하고 싶을 때
        dogs.splice(1,2);
        console.log(dogs);


        //02. 원본배열을 변경하지 않고 참조만 하는 메서드
        //🖤join()🖤 문자열로 반환
        //🖤slice(start, end)🖤 배열의 일부분을 배열로 반환(end는 포함 안함 /end앞까지만 포함되는거)
        //🖤concat()🖤 배열을 합쳐서 새로운 배열을 반환
        //toString() 문자열로 반환
        //🖤indexOf()🖤 전달받은 값과 동일한 값이 배열요소에 있으면 그 요소의 인덱스를 반환 / 없으면 -1을 반환
        //🖤includes()🖤 전달받은 값과 동일한 값이 배열요소에 있으면 true / 없으면 false를 반환

        let arr = ['hi','안녕','그린','목요일'];
        // let str = arr.join();           //그대로 있고 문자만 반환해줌!(소괄호 안에 아무것도 안주면 그냥 글자)
        // let str = arr.join('💛');      //join은 '구분자'줄 수 있음 -> 넣어서 문자 사이에 추가해 줄 수도 있음    
        let str = arr.join('+'); 
        console.log(arr);
        console.log(str);

        let nArr = arr.slice(1,2);
        let nArr1 = arr.slice(1,3);
        console.log(nArr);
        console.log(nArr1);

        let nArr2 = arr.concat([1,2,3]);        //concat이용
        let nArr3 = [...arr,1,2,3];             //스프레드 기법 (위에꺼랑 같은고)
        console.log(nArr2);
        console.log(nArr3);
        let str2 = arr.toString();          //join과 달리 따로 구분자가 없음!!
        console.log(str2);

        //03. 원본배열을 반복적으로 참조하는 메서드 (콜백함수)  -> 화살표함수가 편함
        //🖤forEach()🖤 
        //🖤map()🖤 
        //🖤filter()🖤
        //🖤reduce()🖤
        //some()
        //🖤find()🖤
        //every()

        let numArr = [10,20,30,40,50];
        // console.log(numArr[0]);
        // console.log(numArr[1]);
        // console.log(numArr[2]);
        // console.log(numArr[3]);
        // console.log(numArr[4]);
        //이렇게 하나하나 다 적어주기 귀찮음 -> forEach나 for문, for..of문

        //1. for문
        // for(let i=0; i<numArr.length; i++){
        //     console.log(numArr[i]);                 //컴퓨터가 반복적으로 해주는 거임
        // }

        //2. for..of문
        // for(let i of numArr){
        //       //i 는 그냥 이름(이름 상관X)  
        //          //of 뒤: 부를 배열을 적어줌
        //          //numArr 배열의 해당하는 값을 꺼내는거임(인덱스 꺼내는거X)
        //     console.log(i);
        // }

        //3. forEach문
        // numArr.forEach(function(val, index, arr){
        //                         //값이랑 인덱스만 필요하면 배열 맨마지막은 안적어줘도 됨
        // })
        // function forEach(){              //이런 함수를 저렇게 콜백함수!

        // }
        let newNumArr = [];
        numArr.forEach(function(a,b){
            newNumArr.push(a);              //newNumArr이라는 []빈배열에 forEach안 함수의 매개변수 a->value값 자리!
                                            //-->빈배열에 numArr의 value값을 맨마지막에(push) 넣어줌 ->numArr배열의 값인 10,20,30,40,50을 넣어주는거!
                                            //newNumArr.unshift(a); 로 주면 맨앞에 추가 -> 반대로 나옴 50,40,30,20,10
            console.log(a,b);         
        })
        console.log(newNumArr);             //[10,20,30,40,50] 
        let newNumArr2 = numArr.map(val=> val+5);          //콜백함수는 화살표함수가 편함
        console.log(newNumArr2);
        let newNumArr3 = numArr.find(a=> a > 20);        //값이 20보다 큰 애만 반환해-제일 앞에 하나만 반환
        console.log(newNumArr3);     
        let newNumArr4 = numArr.filter(a=> a > 20);     //값이 20보다 큰 애만 반환해-큰 값 모두 반환
        console.log(newNumArr4);
        let booleanVal1 = numArr.some(val=> val > 30);    // val 값이 30 넘는 애가 있으면 ->true (하나라도 true면 true반환)
        console.log(booleanVal1);
        let booleanVal2 = numArr.every(val=> val > 30);    // 모든 val 값이 다 30 되야함 (모든 요소가 다 true일 때 -> true/ 아니면 ->false)
        console.log(booleanVal2);
        // 배열.forEach((각 배열요소의 값, 각 배열요소의 인덱스, 원본배열)=>{})
        // 배열.reduce((누적값,현재값,인덱스,원본배열)=>{},초기값)
        //누적값?                           콜백함수 다음, 오는거 초기값 // 두번째 매개변수임: 초기값(줘도되고 안줘도됨)
        let numArr2 = [1,2,3,4,5,6];
        let sum=0;
        numArr2.forEach(val=>{
            sum = sum + val;
        })
        // let result = sum;
        // console.log(result);

        // numArr2.reduce((pre,cur)=>{
        //     return pre+cur;
        // },0)

        let result = numArr2.reduce((pre,cur)=>{pre+cur});
        console.log(result);
        //*초기값이 있을 때, 초기값=0
        //        pre      cur        return
        // 1.     0         1         0+1=1
                    //cur(numArr2의 0번째 인덱스 값:1) 
        // 2.     1         2          3
        // 3.     3         3          6
        // 4.     6         4          10
        // 5.     10        5          15      ....
             
        //*초기값이 없을 때
        //        pre      cur        return
        // 1.     0         1          1
        // 2.     1         2          3
        // 3.     3         3          6
        // 4.     6         4          10
        // 5.     10        5          15      ....


        //위에 map으로 준거 reduce로 해보기
        let result2 = numArr.reduce((pre,cur)=>{                //초기값을 []배열로 줌
            pre.push(cur+5);
            return pre;
        },[])           
        //        pre        cur      return
        // 1.     []         1          cur+5: 1+5=6 -> [6] (return 해주는 애가 pre로 []배열에 맨마지막에(push)추가라서 [6]임)
        // 2.     [6]        2          [6,7]
        // 3.     [6,7]      3          [6,7,8]
        // 4.     [6,7,8]    4          [6,7,8,9]  등등
        console.log(result2);
    </script>
</body>
</html>